module Game.Chess.Board where

import Control.Arrow (first)
import Control.Monad.ST.Lazy
import Data.Bits
import Data.List (intercalate, intersperse)
import Data.List.Split (chunksOf)
import Data.STRef.Lazy
import Data.Word
import qualified Data.Vector as V
import Game.Chess.Types

isOnBoard :: (Num a, Bits a) => a -> Bool
isOnBoard a = a .&. 0x88 == 0
{-# INLINE isOnBoard #-}

-- | Index into the 'Board' at the given 'Position'. This function\'s safety is
-- given by the fact that the fields of a 'Position' can only be generated by
-- smart constructors which guarantee that we remain within bounds.
--
-- As such, we don't return 'Maybe Cell' here.
index :: Board -> Position -> Cell
index b pos = board b V.! fromEnum pos
{-# INLINE index #-}

-- | Changes the given 'Position' on the given 'Board' to contain an 'Empty'
-- Cell instead of a 'Cell'. Yo dawg.
emptyCell :: Position -> Board -> Board
emptyCell = flip updateCell Empty
{-# INLINE emptyCell #-}

-- | Updates the given 'Position' on the given 'Board' to be the given 'Cell'.
updateCell :: Position -> Cell -> Board -> Board
updateCell pos cell brd = brd { board = doUpdate (board brd) }
  where
    doUpdate v = V.update v (V.fromList [(fromEnum pos, cell)])
    {-# INLINE doUpdate #-}
{-# INLINE updateCell #-}

isEmptyCell :: Cell -> Bool
isEmptyCell Empty = True
isEmptyCell _     = False
{-# INLINE isEmptyCell #-}

-- | Get a list of every piece owned by a side, and the position it is at.
--
-- This is inefficient right now.
everyPiece :: Board -> Color -> V.Vector (Position, Cell)
everyPiece brd c =
  V.map idxToPosition $
  V.filter (
    \(_, cell) -> not (isEmptyCell cell)
                  && color cell == c) (V.zip indexedBrdVec brdVec)
  where
    brdVec = board brd
    indexedBrdVec = V.fromList [0..V.length brdVec]
    idxToPosition = first toEnum

-- | Given 'Position's @p1@ and @p2@, replace @p2@\'s 'Cell' with @p1@\'s 'Cell'
-- and set @p1@\'s 'Cell' to 'Empty'.
move :: Position -> Position -> Board -> Board
move p1 p2 brd = runST $ do
  let cellAtP1 = index brd p1
  st <- newSTRef brd
  modifySTRef st (updateCell p2 cellAtP1)
  modifySTRef st (emptyCell p1)
  readSTRef st

-- | An initial 'Board' with all 'Piece's in their normal starting position.2
initialBoard :: Board
initialBoard =
  Board
  (V.fromList generateBoard)
  White
  [Kingside Black, Kingside White, Queenside Black, Queenside White]
  Nothing
  0
  0
  where
    generateBackRank c =
      fmap
      (`Cell` c)
      [Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook]
    generatePawnRank c = replicate 8 (Cell Pawn c)
    generateEmptyRank = replicate 8 Empty
    -- This is in order of index, not in actual order.
    generateBoard =
        generateBackRank White ++ generateEmptyRank ++
        generatePawnRank White ++ generateEmptyRank ++
        generateEmptyRank ++ generateEmptyRank ++
        generateEmptyRank ++ generateEmptyRank ++
        generateEmptyRank ++ generateEmptyRank ++
        generateEmptyRank ++ generateEmptyRank ++
        generatePawnRank Black ++ generateEmptyRank ++
        generateBackRank Black ++ generateEmptyRank

prettyPrintBoard :: Board -> String
prettyPrintBoard brd = prettyPrintCells . V.toList . board $ brd

-- This is really inefficient for now.
prettyPrintCells :: [Cell] -> String
prettyPrintCells cs =
  (++ " |") .
  (" | " ++) .
  intersperse ' ' .
  concat .
  intercalate ["|\n|"] .
  reverse .
  map (map show) .
  dropEvery 2 .
  chunksOf 8 $ cs
  where
    dropEvery _ [] = []
    dropEvery n xs = take (n-1) xs ++ dropEvery n (drop n xs)
